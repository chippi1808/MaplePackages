print("psdgcd, a program for automatic proving inequalities and solving optimization probelms.");
print([hantwoSample,hantSample,ineqreal,proineqB,opencadSample,proineqBprojGcd,proineqBproj,psdhp,ineqpst,newineqpst,findk,findkmax,samples,cyc,cyctq,cyclic]);
print("psdgcd, 2009-2014 by Jingjun Han"):
#print("Please give me an inequality"):
#print("proineq, a program for automatic proving inequalities and solving optimization probelms."):
#print("RM can treat radical problems"):
#print("nvd can treat polynomial inequality"):

#print("Example1,RM(cyc((y/(y+2*x))^(1/2),[x,y,z])<=19/10):"):
#print("proineq can prove inequalities without any conditions. findkmax returns maximal value of the parameter such that the inequality holds, cyctq can deal with cyclic ternary quartic forms problems."):
#findk returns all possible values such that the inequality holds
#print("function rads is from software "Bottema" by Lu Yang etc."):
#print("For inequalities with extra conditions, please try the function pineq"):
print("Example,hantSample((a^2+b^2+c^2)^2-3*(a^3*b+b^3*c+c^3*a)):","gcdcad"):
print("Example,proineq((a^2+b^2+c^2)^2-3*(a^3*b+b^3*c+c^3*a)):","old program"):
print("Example,findkmax((x^2-x+1)*(y^2-y+1)*(z^2-z+1)-m*(x^2*y^2*z^2-x*z*y+1),[x,y,z],m):"):
print("Example,ineqreal((a^2+b^2+c^2)^2-3*(a^3*b+b^3*c+c^3*a),[],2):","real numbers with constraints"):
#print("Example4,ineqpst((a^2+b^2+c^2)^2-3*(a^3*b+b^3*c+c^3*a),2):","positive numbers"):
print("Example,psdhp((a^2+b^2+c^2)^2-3*(a^3*b+b^3*c+c^3*a),2):","real numbers"):
#print("Example6,newineqpst((a^2+b^2+c^2)^2-(3+1/1000000000000000000000)*(a^3*b+a*c^3+b^3*c), 2)","positive numbers"):
#print("Example3,findk((a^2+b^2+c^2)^2-k*(a^3*b+b^3*c+c^3*a),[a,b,c],k):"):
#print("Example4,cyctq((a^2+b^2+c^2)^2-(3-1/10^100000)*(a^3*b+b^3*c+c^3*a)):"):
#print("Example5,ineqpst(a^3+b^3+c^3-3*a*b*c,[a,b,c]):"):
#print("infolevel[proineq] := 2 will give you more details"):
#print("benchmark1(k,solver): f:=(\sum_{i=1}^k x_i^2)^2-4\sum_{i=1}^k x_i^2x_{i+1}^2, solver=1 (han projection with gcd): solver=2 (brown projection with gcd): solver=3 (brown projection without gcd)"):

with(linalg):
with(combinat):
##################################
Test:=proc(v,d,n)
     local tim,nu,L,i,a,ti,L1,L2,j,L3,b,c:
L:=[]:
L1:=[]:
L2:=[]:
L3:=[]:
for i to n do
L:=[op(L),randpoly([seq(a[i],i=1..v)], degree = d)]:
od:
for j to nops(L) do
tim:=time():
#nu:=nops(hantSample(L[j],2)):
#tim:=time()-tim:
L2:=[op(L2),hantSampletest(L[j],2)]:
od:
for j to nops(L) do
tim:=time():
#nu:=nops(hantSample(L[j],2)):
#tim:=time()-tim:
L3:=[op(L3),hantSampletest(L[j],3)]:
od:
for j to nops(L) do
tim:=time():
#nu:=nops(opencadSample(L[j],2)):
#tim:=time()-tim:
L1:=[op(L1),opencadSampletest(L[j])]:
od:
for j to 4 do
a[j]:=add(L1[i][j],i=1..nops(L1))/nops(L1):
od:
for j to 4 do
b[j]:=add(L2[i][j],i=1..nops(L2))/nops(L2):
od:
for j to 4 do
c[j]:=add(L3[i][j],i=1..nops(L3))/nops(L3):
od:
#return (L1,L2,L3,[seq(a[i],i=1..4)],[seq(b[i],i=1..4)],[seq(c[i],i=1..4)]):
return ([seq(a[i],i=1..4)],[seq(b[i],i=1..4)],[seq(c[i],i=1..4)]):
end:

#####################################
proineq:=proc(poly)
	local tim,nu:
	tim:=time(): 
	nu:=proineq0(poly):
	if nu=false then 
		print(`Not psd`): print("time(s)"): print(time()-tim):return false:
	end if:
	print("time(s)"):
	print(time()-tim):
	print("sample points:"):
	print(nu):
	print(`psd`):return true:
end:


#############################################
# compute all sample points during han projection
# with gcd
############################################
hantwoSample:=proc(poly)
	local tim,var,vars,l,A,i,j,k,t,L,f,g,h,Li,sa,hen,L1,g1,h1,g2,h2,g3,h3,g4,h4,L2,L3,L4,s,j1:
	sa:=[]:
	hen:=[]:
	tim:=time(): 
	f:=primpart(sqrfree1(poly)):
	if f=1 then
		return sa:
	fi:
	var:=[op(indets(poly))]:
        vars:=nops(var):
	if degree(f)=ldegree(f) then 
		if v=1 then
			print(`Homogenous`):
		fi:
		hen:=var[vars]=1:
		f:=primpart(sqrfree1(subs(hen,f))): 
		var:=[op(indets(f))]:
                vars:=nops(var): 
	fi:
	if f=1 then
		return [[hen]]:
	fi:

	L:=[[f,1]]:
	s:=0:
	j:=1:
	if vars>1 then  
		for j from vars to 3 by -2  do 
			g1:=res(f,var[j]):
			L:=[op(L),[g1,1]]:
			g2:=res(f,var[j-1]):
			g1:=res(g1,var[j-1]):
			g2:=res(g2,var[j]):
			f:=gcd(g1,g2):
			L:=[op(L),[f,g1]]:
		end do:
	end if:
	i:=j:

	for j from i to 2 by -1  do
		f:=res(f,var[j]):
		L:=[op(L),[f,1]]:
	end do:
        print(L):
	sa:=p2Sample(L,1):
	sa:=addPre(sa,hen):
	return sa:
end:
##################################
#inequality in real numbers with constraints
####################################
ineqreal:=proc(poly,polys,t)
local tim,var,vars,l,A,i,j,k,L,f,g,h,Li,sa,hen,L1,g1,h1,g2,h2,g3,h3,g4,h4,L2,L3,L4,s,j1,nu,nu1:
f:=poly:
L2:=polys:
g:=1:
tim:=time():
if nops(polys)=0 then psdhp(f,t): 
else 	#nu:=0:
	var:=[op(indets([f,op(L2)]))]:
        vars:=nops(var):
	#L:=sqrfree5s(sqrfree2(numer(f))):
        L:=[sqrfree2(numer(f))]:
	if L=false then 
		return false: 
	elif L=true then
		return true:
	else
		for j to nops(L) do
                        if nops(L)>1 then
                        print(L[j]):
                        fi:
			nu1:=ineqhp(L[j],L2,t):
			if nu1=false then
                                #print(Not psd):
				return false:
			#else nu:=nu1+nu: 
			fi:
		od:
	fi:
fi:
	#return nu:
print(time()-tim): 
return true:                                                          
end:
################################
############################################
#inequality with constraints
##########################################

ineqhp:=proc(poly,polys,t)
local tim,var,vars,l,A,i,j,k,L,f,g,h,Li,sa,hen,L1,g1,h1,g2,h2,g3,h3,g4,h4,L2,L3,L4,s,j1:
f:=poly:
L2:=polys:
g:=1:
tim:=time():
if nops(polys)=0 then psdhp(f,t): 
else for i to nops(L2) do
     g:=g*L2[i]:
     od:
    var:=[op(indets([f,op(L2)]))]:
    # var:=[op(indets(poly))]:
     vars:=nops(var):
    # print(f*g):
     sa:=hantSample1(f*g,t):
     for i to nops(sa) do
        # print(sa[i]):
        # print(sa[i],L2,f):
         if subs(seq(var[j]=sa[i][j],j=1..vars),f)<0 then s:=1: for k to nops(L2) while s=1 do
                                                                 if subs(seq(var[j]=sa[i][j],j=1..vars),L2[k])<0 then s:=0: fi:
                                                                od:
                                                                if s=1 then #print(time()-tim): 
                                                                   return false: 
                                                                fi:
         fi:
    od:
fi:
#print(time()-tim): 
return true:                                                          
end:
############################################
#inequality with non-negative numbers
##########################################

ineqpst:=proc(poly,t)
local tim,var,vars,l,A,i,j,k,L,f,g,h,Li,sa,hen,L1,g1,h1,g2,h2,g3,h3,g4,h4,L2,L3,L4,s,j1,nu1,PP:
f:=poly:
g:=1:
tim:=time():
var:=[op(indets(f))]:
        vars:=nops(var):
	L:=sqrfree5s(sqrfree2(numer(f))): #print(L):
	if L=false then 
		return false: 
	elif L=true then
		return true:
	else
		for j to nops(L) do
			(nu1,PP):=ineqpp(L[j],t,1,{}):
			if nu1=false then print(nops(PP),time()-tim): return false:
			#else nu:=nu1+nu: 
			fi:
		od:
	fi:
print(nops(PP)):
print(time()-tim): 
return true:                                                          
end:                                                     
############################################
ineqpp:=proc(poly,v,w,pp)
	local var,vars,l,A,i,j,k,t,L,f,g,h,Li,nu,nu1,L1,g1,h1,g2,h2,g3,h3,g4,h4,L2,L3,L4,s,j1,PP,tim,tim1,vars1,vars2,var1:
	nu:=true:
        l:=1:
        PP:=pp:
	f:=sqrfree2(poly):#print("Now, prove the nonnegative of",f):
       # if w=1 then print(f):fi:
	if f=1 then 
		return (nu,PP):
	fi:
        if f=-1 then 
		return (false,PP):
	fi:
	var:=[op(indets(poly))]:
        vars:=nops(var):
	# print(poly,'poly'):
	if degree(poly)=ldegree(poly) then 
		if l=1 then
			print(`Homogenous`):
		fi:
		f:=subs(var[vars]=1,poly): 
                if is (f in PP)=true then PP:=PP union {f}: print("AP1"): return (nu,PP): 
                              else PP:={f} union PP: #print(PP):
                fi:
		var:=[op(indets(f))]:vars:=nops(var): 
        fi:
		if f=1 then
			return (nu,PP): #true:
		fi:
       # print(f):
        if vars-1>v then vars2:=v else vars2:=vars-1:fi:
        if vars>1 then #if w=1 then print(f,[var,vars,v]): fi:
                        #if w=1 then print(`Projection Phase`, "hproj"):tim1:=time():fi:
                  #(L):=hantSample2(f,v): 
                 #  if w=1 then tim:=time()-tim1: tim1:=time(): print(L,tim): print(`Projection Phase finished`, `Lifting Phase`): fi:
                  for i from vars-vars2+1 to vars do
                   #  if w=1 then print(i,vars,var): fi:
                      g:=sqrfree2(subs(var[i]=0,f)): 
                  #    if w=1 then print(g,'h'): fi:
                      if g^2<>1 then
                          if is (g in PP)=true then #PP:={g} union PP:
                             else PP:={g} union PP: #print(PP):
                              # if w=1 then print(g,'w'): fi:
                                var1:=[op(indets(g))]:
                                vars1:=nops(var1):
                                 if vars1-1>v then vars2:=v: else vars2:=vars1-1:fi:
                        #          if w=1 then print(g,vars2,PP): fi:
                               (nu,PP):=ineqpp(g,vars2,0,PP):
                        #           if w=1 then print(nu,PP,'j'): fi:
                                     if nu=false then return (false,PP):
                                     fi:
                           fi:  
                       fi:
                   od:
                         #   if w=1 then print('w'): fi:
                  nu1:=hantSample2(f,v): #if w=1 then print(nu1): fi:
                             for i to nops(nu1) do
                                if is(subs(seq(var[j]=nu1[i][j],j=1..vars),f)<0)=true then
				                      return (false,PP): 
				#else nu:=nu+nu1:
				fi: 
                             od:
                  #print(nu1,f):	
	else #print(f,'f'): 
		if uspensky2p(sqrfree2(f),op(var))<>[] then
			return (false,PP):
		fi:
	fi:
      #  if w=1 then tim:=time()-tim1:  tim1:=time():
      #     print(`Lifting Phase completed`, tim): 
      #  fi:
	#print(nu1,'nu',nu,L):
     #   print(PP):
       	return (nu,PP):
end:
###########################################
############################################
#inequality with non-negative numbers
##########################################

newineqpst:=proc(poly,t)
local tim,var,vars,l,A,i,j,k,L,f,g,h,Li,sa,hen,L1,g1,h1,g2,h2,g3,h3,g4,h4,L2,L3,L4,s,j1,nu1,PP:
f:=poly:
g:=1:
tim:=time():
var:=[op(indets(f))]:
        vars:=nops(var):
	L:=sqrfree5s(sqrfree2(numer(f))): #print(L):
	if L=false then 
		return false: 
	elif L=true then
		return true:
	else
		for j to nops(L) do
			nu1:=newineqpp(L[j],t):
			if nu1=false then print(time()-tim): return false:
			#else nu:=nu1+nu: 
			fi:
		od:
	fi:
print(time()-tim): 
return true:                                                          
end:     
#############################################
############################################
newineqpp:=proc(poly,v)
	local var,vars,l,A,i,j,k,t,L,f,g,h,Li,nu,nu1,L1,g1,h1,g2,h2,g3,h3,g4,h4,L2,L3,L4,s,j1,PP,tim,tim1,vars1,vars2,var1:
	nu:=true:
        l:=1:
      	f:=sqrfree2(poly):#print("Now, prove the nonnegative of",f):
     	if f=1 then 
		return nu:
	fi:
        if f=-1 then 
		return false:
	fi:
	var:=[op(indets(poly))]:
        vars:=nops(var):
	# print(poly,'poly'):
	if degree(poly)=ldegree(poly) then 
		if l=1 then
			print(`Homogenous`):
		fi:
		f:=subs(var[vars]=1,poly): 
               	var:=[op(indets(f))]:vars:=nops(var): 
        fi:
		if f=1 then
			return nu: #true:
		fi:
       # print(f):
        if vars>1 then nu1:=newhantSample2(f,v):  print(nops(nu1),nu1):
                             for i to nops(nu1) do
                                if is(subs(seq(var[j]=nu1[i][j],j=1..vars),f)<0)=true then
				                      return false: 
				fi: 
                             od:
                  #print(nu1,f):	
	else #print(f,'f'): 
		if uspensky2p(sqrfree2(f),op(var))<>[] then
			return false:
		fi:
	fi:
      #  if w=1 then tim:=time()-tim1:  tim1:=time():
      #     print(`Lifting Phase completed`, tim): 
      #  fi:
	#print(nu1,'nu',nu,L):
     #   print(PP):
       	return (nu,PP):
end:
###########################################
#############################################
# compute all sample points during han projection
# with gcd for ineqpp
############################################
newhantSample2:=proc(poly,t)
	local tim,var,vars,l,A,i,j,k,L,f,g,h,Li,sa,hen,L1,g1,h1,g2,h2,g3,h3,g4,h4,L2,L3,L4,s,j1:
	sa:=[]:
	hen:=[]:
	tim:=time(): 
	f:=primpart(sqrfree1(poly)):
	if f=1 then
		return sa:
	fi:
	var:=[op(indets(poly))]:
        vars:=nops(var):
	if degree(f)=ldegree(f) then 
		if v=1 then
			print(`Homogenous`):
		fi:
		hen:=1:
		f:=primpart(sqrfree1(subs(var[vars]=1,f))): 
		var:=[op(indets(f))]:
                vars:=nops(var): 
	fi:
	if f=1 then
		return [[hen]]:
	fi:
       #print(f,[var,vars,t]):
        L:=hprojt(f,[var,vars,t]):
        print(L):
	sa:=newp2Sample2(L,1):
	sa:=addPre(sa,hen):
	return sa:
end:
#############################################
# compute all sample points during han projection
# with gcd for ineqpp
############################################
hantSample2:=proc(poly,t)
	local tim,var,vars,l,A,i,j,k,L,f,g,h,Li,sa,hen,L1,g1,h1,g2,h2,g3,h3,g4,h4,L2,L3,L4,s,j1:
	sa:=[]:
	hen:=[]:
	tim:=time(): 
	f:=primpart(sqrfree1(poly)):
	if f=1 then
		return sa:
	fi:
	var:=[op(indets(poly))]:
        vars:=nops(var):
	if degree(f)=ldegree(f) then 
		if v=1 then
			print(`Homogenous`):
		fi:
		hen:=1:
		f:=primpart(sqrfree1(subs(var[vars]=1,f))): 
		var:=[op(indets(f))]:
                vars:=nops(var): 
	fi:
	if f=1 then
		return [[hen]]:
	fi:
       #print(f,[var,vars,t]):
        L:=hprojt(f,[var,vars,t]):
        #print(L):
	sa:=p2Sample2(L,1):
	sa:=addPre(sa,hen):
	return sa:
end:
#############################################
# compute all sample points during han projection
# with gcd for ineqhp
############################################
hantSample1:=proc(poly,t)
	local tim,var,vars,l,A,i,j,k,L,f,g,h,Li,sa,hen,L1,g1,h1,g2,h2,g3,h3,g4,h4,L2,L3,L4,s,j1:
	sa:=[]:
	hen:=[]:
	tim:=time(): 
	f:=primpart(sqrfree1(poly)):
	if f=1 then
		return sa:
	fi:
	var:=[op(indets(poly))]:
        vars:=nops(var):
	if degree(f)=ldegree(f) then 
		if v=1 then
			print(`Homogenous`):
		fi:
		hen:=1:
		f:=primpart(sqrfree1(subs(var[vars]=1,f))): 
		var:=[op(indets(f))]:
                vars:=nops(var): 
	fi:
	if f=1 then
		return [[hen]]:
	fi:
       #print(f,[var,vars,t]):
        L:=hprojt(f,[var,vars,t]):
        #print(L):
	sa:=p2Sample1(L,1):
	sa:=addPre(sa,hen):
	return sa:
end:
#############################################
# compute all sample points during han projection
# with gcd
############################################
hantSample:=proc(poly,t)
	local tim,var,vars,l,A,i,j,k,L,f,g,h,Li,sa,hen,L1,g1,h1,g2,h2,g3,h3,g4,h4,L2,L3,L4,s,j1:
	sa:=[]:
	hen:=[]:
	tim:=time(): 
	f:=primpart(sqrfree1(poly)):
	if f=1 then
		return sa:
	fi:
	var:=[op(indets(poly))]:
        vars:=nops(var):
	if degree(f)=ldegree(f) then 
		if v=1 then
			print(`Homogenous`):
		fi:
		hen:=var[vars]=1:
		f:=primpart(sqrfree1(subs(hen,f))): 
		var:=[op(indets(f))]:
                vars:=nops(var): 
	fi:
	if f=1 then
		return [[hen]]:
	fi:
       #print(f,[var,vars,t]):
        L:=hprojt(f,[var,vars,t]):
        #print(L):
        print(time()-tim):
	sa:=p2Sample(L,1):
	sa:=addPre(sa,hen):
	return sa:
end:
######################
hprojt:=proc(poly,List)
local var,vars,l,A,i,j,k,L,g,h,Li,sa,hen,L1,g1,h1,g2,h2,g3,h3,g4,h4,L2,L3,L4,s,j1,var1,vars1,t,f:
f:=poly:
h:=1:
L:=[]:
var:=List[1]:
vars:=List[2]:
t:=List[3]:
	j:=1:
	if vars>1 then  
		for j from vars to t+1 by -t do 
                        #print(j):
                        var1:=[seq(var[j-t+1+s],s=0..t-1)]: #print(var1,t):
                        L1:=hproj([f,1],[var1,t]): #print(L1):
			L:=[op(L),op(L1)]:
                        f:=L1[t][1]:h:=L1[t][2]:#print(f):
		end do:
        i:=j: #print(i,'i',L):
         if i>1 then
          #print(factor(f),i,[seq(var[s],s=2..i)]):
         L1:=hproj([f,h],[[seq(var[s],s=2..i)],i-1]):
                L:=[op(L),op(L1)]:
           fi:
	end if:
L:=[[poly,1],op(L)]:
return L:
end:
########################################
hproj:=proc(List1,List)
local var,vars,l,A,i,j,k,L,g,Li,sa,hen,L1,g1,h1,g2,h2,g3,h3,g4,h4,L2,L3,L4,s,j1,B,f,h:
L:=[]:
f:=List1[1]:
h:=List1[2]:
var:=List[1]:
vars:=List[2]:
#t:=List[3]:
#L1:=[seq(var[vars-j+1],j=1..t)]:
L1:=var:
for j to vars do
  h1[var[j]]:=res(f,var[j]):
  h2[var[j]]:=1:
od:

for j from 2 to vars do
    A:=choose(L1,j); 
    for i to nops(A) do
      #print(A[i]):
      B:=twoLists(A[i]): #print(B):
      for k to j do
       # print([op(B[k][1])],B[k][2]):
        #print(h1[op(B[k][1])]):
        h1[op(B[k])]:=res(h1[op(B[k][1])],B[k][2]):
        #print(h1[op(B[k])],op(B[k])):
      od:
       h3:=h1[op(B[1])]:
      for k from 2 to j do
        h3:=gcd(h3,h1[op(B[k])]):
      od:
      h1[op(A[i])]:=h3:
      #h1[op(A[i])]:=gcd(seq(h1[op(B[k])],k=1..j)):
        #print(h1[op(A[i])],[op(A[i])]):
      h2[op(A[i])]:=h1[op(B[j])]:
    od:
od:
#print(h1):
#print(vars):
for j from vars to 1 by -1 do
if j<vars then
h2[seq(var[t],t=j..vars)]:=lcoeff(h2[seq(var[t],t=j+1..vars)],var[j])*h2[seq(var[t],t=j..vars)]:
else
h2[seq(var[t],t=j..vars)]:=lcoeff(h,var[j])*h2[seq(var[t],t=j..vars)]:
fi:
#print('j',j):
#print(var,j):
#print(var[j]):
#print(h1[seq(var[t],t=j..vars)],j):
 L:=[op(L),[h1[seq(var[t],t=j..vars)],h2[seq(var[t],t=j..vars)]]]:
od:
return L:
end:

#########################################
twoLists:=proc(L)
local i,j,L1,A1,A2,A,t:
L1:=[]:
#print(L):
  for j to nops(L) do
      #print(j):
      A1:=[seq(L[t],t=1..j-1)]: #print(A1):
      A2:=[seq(L[t],t=j+1..nops(L))]:#print(A2):
      A:=[[op(A1),op(A2)],L[j]]: 
      L1:=[op(L1),A]: #print(L1):
  od:
return L1:
end:

##########################################
#add pre sa=[[x=1,y=2]], pr=[z=3] 
#return [[z=3,x=1,y=2]]:
#########################################
addPre:=proc(sa,pr)
	local re, s:

	if pr=[] then 
		return sa:
	end if:

	re:=[]:
	for s in sa do 
		re:=[op(re),[pr,op(s)]]:
	end do:

	return re:
end:


#####################################
proineqB:=proc(poly)
	local tim,nu:
	tim:=time(): 
	nu:=proineq11(poly,1):
	if nu=false then print(`Not psd`): print("time(s)"):print(time()-tim):
		return false:
	fi:
	print("time(s)"):
	print(time()-tim):
	print("sample points:"):
	print(nu):
	print(`psd`):return true:
end:

##########################
#compute opencad sample points
##############################
opencadSample:=proc(poly)
	local tim,var,vars,l,A,i,j,k,t,L,f,g,h,Li,sa,hen,L1,g1,h1,g2,h2,g3,h3,g4,h4,L2,L3,L4,s,j1:

	sa:=[]:
	hen:=[]:
	tim:=time(): 
	f:=primpart(sqrfree1(poly)):#print("Now, prove the nonnegative of",f):
	if f=1 then
		return sa:
	fi:
	var:=[op(indets(poly))]:vars:=nops(var):
	if degree(poly)=ldegree(poly) then 
		if v=1 then
			print(`Homogenous`): 
		fi:
		hen:=var[vars]=1:
		f:=primpart(sqrfree1(subs(hen,f))): 
		var:=[op(indets(f))]:vars:=nops(var): 
	fi:
	if f=1 then
		return [[hen]]:
	fi:
	L:=[[f,1]]:
	h:=1:
	s:=0:
	if vars>1 then  
		for j from vars to 2 by -1  do
			f:=res(f,var[j]):
			L1:=sqrfree2(f):
			L:=[op(L),[L1,1]]:
		end do:
	fi:
        #print(time()-tim):
	sa:=p2Sample(L,1):
	sa:=addPre(sa,hen):
	return sa:
end:




##########################
#Apply brown projection without gcd
##############################
proineqBproj:=proc(poly)
	local tim,var,vars,l,A,i,j,k,t,L,f,g,h,Li,nu,nu1,L1,g1,h1,g2,h2,g3,h3,g4,h4,L2,L3,L4,s,j1:
	nu:=0:
	tim:=time(): 
	f:=poly:#print("Now, prove the nonnegative of",f):
	if f=1 then
		return true:
	fi:
	var:=[op(indets(poly))]:vars:=nops(var):
	if degree(poly)=1 mod 2 then
		return false:
	fi:
	if degree(poly)=ldegree(poly) then 
		if v=1 then
			print(`Homogenous`): 
		fi:
		f:=subs(var[vars]=1,poly): 
		var:=[op(indets(f))]:vars:=nops(var): 
	fi:
	if f=1 then
		return true:
	fi:
	L:=[[f,1]]:
	h:=1:
	s:=0:
	if vars>1 then  
		if vars=2 then 
			g1:=dis(f,var[vars]): 
			if g1=false then
				return false:
			fi: #print(g,"g"):
			h:=sqrfree2(numer(g1)): #print(L1,`L1[1]`,f):
			if is(h<0)=true then
				return false:
			fi:
			L:=[op(L),[h,1]]:  
			nu1:=proineq2(L,1):  
			if nu1=false then 
				return false: 
			else nu:=nu+nu1:
			fi: 
		else 
			for j from vars to 2 by -1  do
				f:=res(f,var[j]):
				L1:=sqrfree2(f):
				L:=[op(L),[L1,1]]:
			end do:
		fi:
	fi:

	nu:=proineq2(L,1):
	if nu=false then
		print(`Not psd`): print("time(s):"):print(time()-tim):return false:
	fi:
	print("time(s):"):
	print(time()-tim):
	print("sample points:"):
	print(nu):
	print(`psd`):return true:

end:
#################################

###################################
# factory resultant choose odd fator
# ##################################

###################################
proineq0:=proc(poly)
	local var,vars,i,j,L,f,nu,nu1:
	nu:=0:
	var:=[op(indets(poly))]:
        vars:=nops(var):
	L:=sqrfree5(sqrfree2(numer(poly))):
	if L=false then 
		return false: 
	elif L=true then
		return true:
	else
		for j to nops(L) do
			nu1:=proineq11(L[j],1):
			if nu1=false then
				return false:
			else nu:=nu1+nu: 
			fi:
		od:
	fi:
	return nu:
end:


###############################
#apply brown projection with gcd
###############################
proineqBprojGcd:=proc(poly)
	local tim,var,vars,l,A,i,j,k,t,L,f,g,h,Li,nu,nu1,L1,g1,h1,g2,h2,g3,h3,g4,h4,L2,L3,L4,s,j1:
	nu:=0:
	tim:=time(): 
	f:=poly:#print("Now, prove the nonnegative of",f):
	if f=1 then
		return true:
	fi:
	var:=[op(indets(poly))]:vars:=nops(var):
	if degree(poly)=1 mod 2 then
		return false:
	fi:
	if degree(poly)=ldegree(poly) then 
		if v=1 then
			print(`Homogenous`):
		fi:
		f:=subs(var[vars]=1,poly): 
		var:=[op(indets(f))]:vars:=nops(var): 
	fi:
	if f=1 then
		return true:
	fi:
	L:=[[f,1]]:
	s:=0:
	if vars>1 then  
		if vars=2 then 
			g1:=dis(f,var[vars]): 
			if g1=false then
				return false:
			fi: #print(g,"g"):
			h:=sqrfree2(numer(g1)): #print(L1,`L1[1]`,f):
			if is(h<0)=true then
				return false:
			fi:
			L:=[op(L),[h,1]]:  
			nu1:=proineq2(L,1):  
			if nu1=false then
				return false:
			else
				nu:=nu+nu1:
			fi: 
		else 
			for j from vars to 3 by -2  do 
				g1:=res(f,var[j]):
				L:=[op(L),[g1,1]]:
				g2:= res(f,var[j-1]):
				g1:=res(g1,var[j-1]):
				g2:=res(g2,var[j]):
				f:=gcd(g1,g2):
				L:=[op(L),[f,g1]]:
			end do:
		end if:
	end if:
	i:=j:

	for j from i to 2 by -1  do
		f:=res(f,var[j]):
		L:=[op(L),[f,1]]:
	end do:

	nu:=proineq2(L,1):
	if nu=false then 
		print(`Not psd`): print("time(s):"): print(time()-tim):return false:
	fi:
	print("time(s):"):
	print(time()-tim):
	print("sample points:"):
	print(nu):
	print(`psd`):return true:

end:

###############################
#apply han projection and gcd
###############################

######################
proineq11:=proc(poly,v)
	local var,vars,l,A,i,j,k,t,L,f,g,h,Li,nu,nu1,L1,g1,h1,g2,h2,g3,h3,g4,h4,L2,L3,L4,s,j1:
	nu:=0:
	f:=poly:#print("Now, prove the nonnegative of",f):
	if f=1 then 
		return true:
	fi:
	var:=[op(indets(poly))]:vars:=nops(var):
	if degree(poly)=1 mod 2 then 
		return false:
	fi:
	if degree(poly)=ldegree(poly) then 
		if v=1 then
			print(`Homogenous`):
		fi:
		f:=subs(var[vars]=1,poly): 
		var:=[op(indets(f))]:vars:=nops(var): fi:
		if f=1 then
			return true:
		fi:
		L:=[[f,1]]:
		h:=1:
		s:=0:
		if vars>1 then  
			if vars=2 then
				g1:=dis(f,var[vars]):
				if g1=false then
					return false: 
				fi: #print(g,"g"):
				L1:=sqrfree3(g1): #print(L1,`L1[1]`,f):
				if L1=false then 
					return false:
				fi: 
				if is(L1[1]<0)=true then return false: fi:
					if nops(L1)>=2 then
						for i from 2 to nops(L1) do
							#print(L1[i]):
							nu1:=proineq11(L1[i],v+1):#print(i,L[i]):
							if nu1=false then
								return false: 
							else nu:=nu+nu1:
							fi:
						od:
					fi:
					#if L1[1]=1 then return nu:fi:
					h:=1:#print(L1):
					for i from 2 to nops(L1) do
						h:=h*lcoeff(L1[i],var[vars]): #print(h,i,"h"):
					od:
					h:=sqrfree1(h*lcoeff(f,var[vars])):
					L:=[op(L),[L1[1],h]]:  
					nu1:=proineq2(L,v):  
					if nu1=false then
						return false: 
					else nu:=nu+nu1:
					fi: 
			else 
					for j from 1 to vars-1 while L<>1 do
						if type(infolevel[proineq], numeric) and infolevel[proineq]>=2 then
							if v=1 then 
								print(j,L[j],vars):
							fi:
						fi:
						#print(f):
						if vars-j>2 then 
							s:=0:
							if j=1 then
								g1:=dis(f,var[vars]):  
								if g1=false then
									return false:
								fi: #print(g,"g"):
								g3:=dis(f,var[vars-1]): 
								if g3=false then
									return false:
								fi: #print(g,"g"):
								L1:=sqrfree3(g1): #print(L1,L1[1],"L1"):
								L2:=sqrfree3(g3): #print(L2,L2[1],"L2"):
								if L2=false then 
									return false:
								fi: #if v=1 then print(L,"v",0):fi:
								if L1=false then return false: fi: #if v=1 then print(L,"v",0):fi:
									if L1[1]<>1 and L2[1]<>1 then
										if nops(L1)>=2 then
											for i from 2 to nops(L1) do
												#print(L[i]):
												nu1:=proineq11(L1[i],v+1):#print(i,L[i]):
												if nu1=false then return false: else nu:=nu+nu1:fi:
												od:
											fi:                            
											h1:=1:
											for i from 2 to nops(L1) do
												h1:=h1*lcoeff(L1[i],var[vars-j+1]): #print(h,i,"h"):
											od:
											h1:=sqrfree1(h1*lcoeff(f,var[vars-j+1])):   
											h3:=1:
											for i from 2 to nops(L2) do
												h3:=h3*lcoeff(L2[i],var[vars-j]): #print(h,i,"h"):
											od:
											h3:=sqrfree1(h3*lcoeff(f,var[vars-j])): 
										        #if degree(L1[1],var[vars-j])=0 and degree(L2[1],var[vars-j+1])=0 
											#	then print("Missing variable"): s:=1:                                                
											#	while degree(L1[1],var[vars-j])=0 and degree(L2[1],var[vars-j])=0 do                                     
											#		L:=[op(L),[L1[1],h1]]:
											#		if j=1 then 
											#			h1:=lcoeff(h1,var[vars-j]):
											#			h3:=lcoeff(h3,var[vars-j+1]):
											#		else h1:=lcoeff(h1,var[vars-j]):
											#			h3:=lcoeff(h3,var[vars-j]):
											#		fi:
											#		j:=j+1 
											#	od:
											#	j1:=j:
											#	#print(j1,"s"):
											#else j1:=j-1:
											#fi:
											g2:=primpart(sqrfree1(res(L1[1],var[vars-j]))):#print(g2,"g2"):
											h2:=lcoeff(h1,var[vars-j]):   
											g4:=primpart(sqrfree1(res(L2[1],var[vars-j1]))):
											h4:=lcoeff(h3,var[vars-j1]):  #print(h4,'h4'): 
											g:=primpart(gcd(g2,g4)): 
                                                                                           #if v=1 then print(j1,j,L1[1],L2[1],g,g2,g4,"s"): fi:
											if g-g2<>0 then
												if type(infolevel[proineq], numeric) and infolevel[proineq]>=2 then
													print("OK",g,g2,g4,v):
												fi:
												if s=1 then
													print ("OK1",g,g2,g4,s):
												fi:
												if nops(L2)>=2 then
													for i from 2 to nops(L2) do                 
														nu1:=proineq11(L2[i],v+1):#print(i,L[i]):
														if nu1=false then
															return false: 
														else nu:=nu+nu1:
														fi:
													od:
												fi:
												h:=sqrfree1(h2*h4): #print(h,"h"):
												L3:=sqrfree3(g):
											#	if nops(L3)>1 then g:=1: 
											#		for i from 2 to nops(L3) do 
											#			if degree(L3[i]) mod 2=1 or lcoeff(L3[i])<0 then
											#				g:=g*L3[i]:
											#			else 
											#				if proineq11(L3[i],v+1)=false then 
											#					if type(infolevel[proineq], numeric) and infolevel[proineq]>=2 then 
											#						print("not redundant"):
											#					fi:
											#					g:=g*L3[i]: 
											#				else if type(infolevel[proineq], numeric) and infolevel[proineq]>=2 then
											#					print("find redundant factor",L3[i]):
											#				fi:
											#				h:=h*L3[i]: 
											#			        fi:
											#		        fi:
											#	       od:
											#        fi:
											L:=[op(L),[L1[1],L2[1],h1,h3],[g,h]]: 
											j:=j+1:
										else if type(infolevel[proineq], numeric) and infolevel[proineq]>=2 then
											print("Not improved"): 
										fi:
										h:=h2:L:=[op(L),[L1[1],h1]]:  
									fi: 

								else L:=1: if L1[1]=1 then 
									if nops(L1)>=2 then
										for i from 2 to nops(L1) do
											nu1:=proineq11((sqrfree2(L1[i])),v+1): #print(i,'nu1'):
											if nu1=false then
												return false: 
											else nu:=nu+nu1:         #print(nu,'nv',j):   
											fi:
										od:
									fi:
								fi:
								if L2[1]=1 then 
									if nops(L2)>=2 then
										for i from 2 to nops(L2) do
											nu1:=proineq11((sqrfree2(L2[i])),v+1): #print(i,'nu1'):
											if nu1=false	then
												return false: 
											else nu:=nu+nu1:         #print(nu,'nv',j):       
											fi:
										od:
									fi:
								fi:
							fi:
						else          
							g1:=primpart(sqrfree1(res(L[j][1],var[vars-j+1]))):#print(g1,var[vars-j],"g1"):
							L3:=sqrfree3(g1): #print(L1,var[vars-j],"L1"):
						#	if nops(L3)>1 then g1:=1: 
						#		for i from 2 to nops(L3) do 
						#			if degree(L3[i]) mod 2=1 or lcoeff(L3[i])<0 then
						#				g1:=g1*L3[i]:
						#			else 
						#				if proineq11(L3[i],v+1)=false then
						#					if type(infolevel[proineq], numeric) and infolevel[proineq]>=2 then
						#						print("not redundant"): 
                                                #                                       fi:
						#						g1:=g1*L3[i]: 
						#				else 
						#						if type(infolevel[proineq], numeric) and infolevel[proineq]>=2 then 
						#							print("find redundant factor",L3[i]):
						#						fi:
						#						h:=h*L3[i]: 
						#				fi:
						#			fi:
						#		od:
						#	fi:                                  
								h1:=lcoeff(h,var[vars-j+1]):
								g2:=primpart(sqrfree1(res(g1,var[vars-j]))):#print(g2,"g2"):
								L4:=sqrfree3(g2):
						#		if nops(L4)>1 then g2:=1: 
						#			for i from 2 to nops(L4) do 
						#				if degree(L4[i]) mod 2=1 or lcoeff(L4[i])<0 then g2:=g2*L4[i]:
						#				else if proineq11(L4[i],v+1)=false then g2:=g2*L4[i]: 
						#				      else if type(infolevel[proineq], numeric) and infolevel[proineq]>=2 then 
                                                #                                              print("find redundant factor",L4[i]): 
                                                #                                            fi:
						#					h1:=h1*L4[i]: 
						#				      fi:
						#			         fi:
						#		         od:
						#	         fi: 
							h2:=lcoeff(h1,var[vars-j]): 
							g3:=primpart(sqrfree1(res(L[j][1],var[vars-j]))):#print(g3,var[vars-j],"g3"):
							h3:=lcoeff(h,var[vars-j]):
							g4:=primpart(sqrfree1(res(g3,var[vars-j+1]))):#print(g4,var[vars-j+1]):
							h4:=lcoeff(h3,var[vars-j+1]):      
							g:=gcd(g2,g4): 
							if g-g2<>0 then
								if type(infolevel[proineq], numeric) and infolevel[proineq]>=2 then
									print("OK"): 
								fi:
								h:=sqrfree1(h2*h4): #print(h,"h"):
								L:=[op(L),[g1,g3,h1,h3],[g,h]]: 
							else 
								if type(infolevel[proineq], numeric) and infolevel[proineq]>=2 then
									print("Not improved"):
								fi:
								h:=h2:L:=[op(L),[g1,h1],[g,h]]:
							fi:
							j:=j+1: #print(j):
						fi:
					else  #print('j',j,L):
						#if nops(L)<>1
						if j=1 then g:=primpart(sqrfree1(dis(L[j][1],var[vars-j+1]))):
						else
							g:=primpart(sqrfree1(res(L[j][1],var[vars-j+1]))): #print(g,vars):
						fi:
						L3:=sqrfree3(g):
					#	if nops(L3)>1 then  g:=1:
					#		for i from 2 to nops(L3) do 
					#			if degree(L3[i]) mod 2=1 or lcoeff(L3[i])<0 then g:=g*L3[i]:
					#			else 
					#				if proineq11(L3[i],v+1)=false then
					#					if type(infolevel[proineq], numeric) and infolevel[proineq]>=2 then 
					#						print("not redundant"): 
					#					fi:
					#					g:=g*L3[i]: 
					#				else if type(infolevel[proineq], numeric) and infolevel[proineq]>=2 then
					#					print("find redundant factor",L3[i]): 
					#				      fi:
					#				h:=h*L3[i]: 
					#			        fi:
					#		        fi:
					#	         od:
					#        fi:
					h:=sqrfree1(lcoeff(h,var[vars-j+1])):
					L:=[op(L),[g,h]]: #print(g,h,`g`):
					#else print(L,'j',j):
					#fi:
				fi:  
			od:
			#print(L,'L'): 
			if L=1 then return nu: 
			else if v=1 then print(L,v): fi:
				nu1:=proineq2(L,v): 
				if nu1=false then
					return false: 
				else nu:=nu+nu1:
				fi: 
			fi:
		fi:
	else #print(f,'f'): 
		if realroot(f)<>[] then
			return false:
		fi:
	fi:
	#print(nu1,'nu',nu,L):
	return nu:
end:
############################################################
###psdhp
###################################
psdhp:=proc(poly,v)
	local var,vars,i,j,L,f,nu,nu1,tim,PP,PP1:
        tim:=time(): PP:={}:
	nu:=0:
	var:=[op(indets(poly))]:
        vars:=nops(var):
	L:= sqrfree5(sqrfree2(numer(poly))):
	if L=false then print(`Not psd`): print(time()-tim):
		return false: 
	elif L=true then print(`psd`): print(time()-tim):
		return true:
	else
		for j to nops(L) do
                        #print(j):
			(nu1,PP1):=psdhnproj(L[j],v,1,PP):
                        PP:=PP1 union PP:
			if nu1=false then print(j,`Not psd`): print(time()-tim):
				return false:
			#else nu:=nu1+nu: 
			fi:
		od:
	fi:
        print(nops(PP),`psd`): print(time()-tim):
        #print(PP):
	return true:
end:

###############################
###############################
#apply hnproj 
###############################

######################
psdhnproj:=proc(poly,v,w,pp)
	local var,vars,l,A,i,j,k,t,L,f,g,h,Li,nu,nu1,L1,g1,h1,g2,h2,g3,h3,g4,h4,L2,L3,L4,s,j1,PP,tim,tim1:
	nu:=true:
        l:=1:
        PP:=pp:
	f:=poly:#print("Now, prove the nonnegative of",f):
        #print(f):
	if f=1 then 
		return (nu,PP):
	fi:
	var:=[op(indets(poly))]:
        vars:=nops(var):
	if degree(poly)=1 mod 2 then 
		return (false,PP):
	fi:
       # print(poly,'poly'):
	if degree(poly)=ldegree(poly) then 
		if l=1 then
			print(`Homogenous`):
		fi:
		f:=subs(var[vars]=1,poly): 
                if is (f in PP)=true then PP:=PP union {f}: print("AP1"): return (nu,PP): 
                              else PP:={f} union PP: #print(PP):
                fi:
		var:=[op(indets(f))]:vars:=nops(var): 
        fi:
		if f=1 then
			return (nu,PP): #true:
		fi:
        
        if vars>1 then #if w=1 then print(f,[var,vars,v]): fi:
                        if w=1 then print(`Projection Phase`, "hnproj"):tim1:=time():fi:
                  (L,PP):=hnprojt(f,[var,vars,v,w,PP]): #if w=1 then print(L,'i'): fi:
                  #print(L,v):
                        if L=false then return (L,PP): fi:
                   if w=1 then tim:=time()-tim1: tim1:=time(): print(L,tim): print(`Projection Phase finished`, `Lifting Phase`): fi:
                  nu1:=proineq2(L,v): 
				if nu1=false then
					return (false,PP): 
				#else nu:=nu+nu1:
				fi: 
                  #print(nu1,f):	
	else #print(f,'f'): 
		if realroot(f)<>[] then
                        #print(f,PP):
			return (false,PP):
		fi:
	fi:
        if w=1 then tim:=time()-tim1:  tim1:=time():
           print(`Lifting Phase completed`, tim): 
        fi:
	#print(nu1,'nu',nu,L):
       	return (nu,PP):
end:

######################################
######################
hnprojt:=proc(poly,List)
local var,vars,l,A,i,j,k,L,g,h,Li,sa,hen,L1,g1,h1,g2,h2,g3,h3,g4,h4,L2,L3,L4,s,j1,var1,vars1,t,f,s1,w,PP:
#print(poly,List):
f:=poly:
h:=1:
L:=[]:
var:=List[1]:
vars:=List[2]:
t:=List[3]:
w:=List[4]:
PP:=List[5]:
s1:=0:
	j:=1:
	if vars>1 then  
		for j from vars to t+1 by -t do 
                       # if w=1 then 
                       #print(j):
                       #fi:
                        var1:=[seq(var[j-t+1+s],s=0..t-1)]: #if w=1 then print(var1):fi:
                           if j=vars then s1:=1: (L1,PP):=hnproj(f,[var1,t,PP]): #if w=1 then print(L1): fi:
                               if L1=false then return (false,PP): fi:
                               else
                            #print(j):
                                L1:=hproj([f,h],[var1,t]): #print(L1):
                                if L1=false then return (false,PP): fi:
                            fi:
			  L:=[op(L),op(L1)]:
                          f:=L1[t][1]:h:=L1[t][2]#print(f):
                 od:
             i:=j: #print(i,'i',poly):
             if i>1 then 
               #print(i,f):
               if s1=1 then L1:=hproj([f,h],[[seq(var[s],s=2..i)],i-1]): #print(L1,s1):
                               if L1=false then return (false,PP): fi:
                         else (L1,PP):=hnproj(f,[[seq(var[s],s=2..i)],i-1,PP]): #print(L1,s1):
                                if L1=false then return (false,PP): fi:
                fi:
                L:=[op(L),op(L1)]:
             fi:
	end if:
L:=[[poly,1],op(L)]:
#print(poly,List,s1):
return (L,PP):
end:
########################################
hnproj:=proc(f,List)
local var,vars,l,A,i,j,k,L,g,Li,sa,hen,L1,g1,h1,g2,h2,g3,h3,g4,h4,L2,L3,L4,s,j1,B,v,nu1,nu,h,vars1,var1,vars2,PP:
#print(f,List):
v:=1:
L:=[]:
var:=List[1]:
vars:=List[2]: 
PP:=List[3]:
#L1:=[seq(var[vars-j+1],j=1..t)]:
L1:=var:
                         for j to vars do
				g1:=dis(f,var[j]):
				if g1=false then
					return (false,PP): 
				fi: #print(g,"g"):
				L3:=sqrfree3(g1): #print(L3,`L3[1]`,f):
				if L3=false then 
					return (false,PP):
				fi: 
				if is(L3[1]<0)=true then return (false,PP): fi:
					if nops(L3)>=2 then 
                                                          for i from 2 to nops(L3) do
							      #print(L3[i],i,nops(L3),'i'):
                                                            if is (L3[i] in PP)=true then #print("AD2"):
                                                            else PP:=PP union {L3[i]}: #print(PP,L3[i]):
                                                                 var1:=[op(indets(L3[i]))]:        
                                                                 vars1:=nops(var1): 
                                                                   if vars>vars1-1 then vars2:=vars1-1 
                                                                                   else vars2:=vars:
                                                                   fi:                             #vars2:=min(vars1-1,vars):
                                                                  # print(L3[i],vars2,PP):
							           (nu1,PP):=psdhnproj(L3[i],vars2,0,PP):#print(nu1,PP,'j'):
							           if nu1=false then
								          return (false,PP): 
							                #else nu:=nu+nu1:
							           fi:
                                                            fi:
						           od:
					fi:
				h1[var[j]]:=L3[1]:		
                                        if j=vars then
                                          h:=1:
					  for i from 2 to nops(L3) do
						h:=h*lcoeff(L3[i],var[j]): #print(h,i,"h"):
                                                h:=sqrfree1(h*lcoeff(f,var[j])):
					  od:
                                          h2[var[vars]]:=h: #print(h2[var[vars]],j,"h2[var[vars]]",var[vars]):
                                        fi:							
                           od:
for j from 2 to vars do
    A:=choose(L1,j); 
    for i to nops(A) do
      #print(A[i]):
      B:=twoLists(A[i]): #print(B):
      for k to j do
       # print([op(B[k][1])],B[k][2]):
        #print(h1[op(B[k][1])]):
        h1[op(B[k])]:=res(h1[op(B[k][1])],B[k][2]):
        #print(h1[op(B[k])],op(B[k])):
      od:
       h3:=h1[op(B[1])]:
      for k from 2 to j do
        h3:=gcd(h3,h1[op(B[k])]):
      od:
      h1[op(A[i])]:=h3:
      #h1[op(A[i])]:=gcd(seq(h1[op(B[k])],k=1..j)):
        #print(h1[op(A[i])],[op(A[i])]):
      h2[op(A[i])]:=h1[op(B[j])]:
    od:
od:
#print(h1):
#print(vars):
for j from vars to 1 by -1 do
#print('j',j):
#print(var,j):
#print(var[j]):
#print(h1[seq(var[t],t=j..vars)],j):
if j<>vars then
 h2[seq(var[t],t=j..vars)]:=lcoeff(h2[seq(var[t],t=j+1..vars)],var[j])*h2[seq(var[t],t=j..vars)]:
fi:
 L:=[op(L),[h1[seq(var[t],t=j..vars)],h2[seq(var[t],t=j..vars)]]]:
od:
#print(f):
return (L,PP):
end:



#################################################
#compute all samples 
##########################################
p2Sample:=proc(List,v)

	local var,vars,l,A,i,j,k,s,t,L,f,L1,L2,L3,L4,L5,P,Ls,sas,sa,g,h,L6,L7,L8,L9:
	L:=List:

	f:=List[1][1]:
	var:=[op(indets(f))]: vars:=nops(var): 
	sa:=samples(List[vars][1],List[vars][2]):
	for j from 2 to vars do
		L3:=[]:
		L4:=[]:
		if nops(L[vars-j+1])=2 then 
			for k to nops(sa) do  
				Ls:=sa[k]:    
				L5:=subs(seq(var[t]=Ls[t],t=1..j-1),L[vars-j+1]):
				L1:=samples(L5[1],L5[2]):
				for t to nops(L1) do
					L3:=[op(L3),[op(Ls),op(L1[t])]]:
				od:
			od:
			sa:=L3:
		else 
			for k to nops(sa) do  #print(k): print(L1):
				Ls:=sa[k]:    
				L5:=subs(seq(var[t]=Ls[t],t=1..j-1),L[vars-j+1]): 
				L1:=samples(sqrfree1(L5[1]),sqrfree1(L5[3])):#print(L1,"L1",L5):
				L2:=samples(sqrfree1(L5[2]),sqrfree1(L5[4])):#print(L2,"L2",L5):
				L5:=subs(seq(var[t]=Ls[t],t=1..j-1),L[vars-j]):
				for t to nops(L1) do
					L6:=subs(var[j]=op(L1[t]),L5):
					L7:=samples(L6[1],L6[2]):
					for s to nops(L7) do
						L3:=[op(L3),[op(Ls),op(L1[t]),op(L7[s])]]:
					od:
				od:
				for t to nops(L2) do
					L6:=subs(var[j+1]=op(L2[t]),L5):
					L7:=samples(sqrfree1(L6[1]),sqrfree1(L6[2])):
					for s to nops(L7) do
						L3:=[op(L3),[op(Ls),op(L7[s]),op(L2[t])]]:
					od:
				od:
			od:
			sa:=L3:
			j:=j+1:
		fi:
	od:
	sas:=[]:

	for i from 1 to nops(sa) do:
		Ls:=sa[i]:
		sas:=[op(sas),[ seq(var[t]=Ls[t],t=1..vars)]]:
	od:

	return sas:
end:
#################################################
#compute all samples for ineqhp
##########################################
p2Sample1:=proc(List,v)

	local var,vars,l,A,i,j,k,s,t,L,f,L1,L2,L3,L4,L5,P,Ls,sas,sa,g,h,L6,L7,L8,L9:
	L:=List:

	f:=List[1][1]:
	var:=[op(indets(f))]: vars:=nops(var): 
	sa:=samples(List[vars][1],List[vars][2]):
	for j from 2 to vars do
		L3:=[]:
		L4:=[]:
		if nops(L[vars-j+1])=2 then 
			for k to nops(sa) do  
				Ls:=sa[k]:    
				L5:=subs(seq(var[t]=Ls[t],t=1..j-1),L[vars-j+1]):
				L1:=samples(L5[1],L5[2]):
				for t to nops(L1) do
					L3:=[op(L3),[op(Ls),op(L1[t])]]:
				od:
			od:
			sa:=L3:
		else 
			for k to nops(sa) do  #print(k): print(L1):
				Ls:=sa[k]:    
				L5:=subs(seq(var[t]=Ls[t],t=1..j-1),L[vars-j+1]): 
				L1:=samples(sqrfree1(L5[1]),sqrfree1(L5[3])):#print(L1,"L1",L5):
				L2:=samples(sqrfree1(L5[2]),sqrfree1(L5[4])):#print(L2,"L2",L5):
				L5:=subs(seq(var[t]=Ls[t],t=1..j-1),L[vars-j]):
				for t to nops(L1) do
					L6:=subs(var[j]=op(L1[t]),L5):
					L7:=samples(L6[1],L6[2]):
					for s to nops(L7) do
						L3:=[op(L3),[op(Ls),op(L1[t]),op(L7[s])]]:
					od:
				od:
				for t to nops(L2) do
					L6:=subs(var[j+1]=op(L2[t]),L5):
					L7:=samples(sqrfree1(L6[1]),sqrfree1(L6[2])):
					for s to nops(L7) do
						L3:=[op(L3),[op(Ls),op(L7[s]),op(L2[t])]]:
					od:
				od:
			od:
			sa:=L3:
			j:=j+1:
		fi:
	od:
	sas:=[]:

	for i from 1 to nops(sa) do:
		Ls:=sa[i]:
		sas:=[op(sas),[seq(var[t]=Ls[t],t=1..vars)]]:
	od:

	return sa:
end:
#####################################
#################################################
#compute all samples for newineqpp
##########################################
newp2Sample2:=proc(List,v)

	local var,vars,l,A,i,j,k,s,t,L,f,L1,L2,L3,L4,L5,P,Ls,sas,sa,g,h,L6,L7,L8,L9:
	L:=List:

	f:=List[1][1]:
	var:=[op(indets(f))]: vars:=nops(var): 
	sa:=newsamplesp(List[vars][1],List[vars][2]):
	for j from 2 to vars do
		L3:=[]:
		L4:=[]:
		if nops(L[vars-j+1])=2 then 
			for k to nops(sa) do  
				Ls:=sa[k]:    
				L5:=subs(seq(var[t]=Ls[t],t=1..j-1),L[vars-j+1]):
				L1:=newsamplesp(L5[1],L5[2]):
				for t to nops(L1) do
					L3:=[op(L3),[op(Ls),op(L1[t])]]:
				od:
			od:
			sa:=L3:
		else 
			for k to nops(sa) do  #print(k): print(L1):
				Ls:=sa[k]:    
				L5:=subs(seq(var[t]=Ls[t],t=1..j-1),L[vars-j+1]): 
				L1:=newsamplesp(sqrfree1(L5[1]),sqrfree1(L5[3])):#print(L1,"L1",L5):
				L2:=newsamplesp(sqrfree1(L5[2]),sqrfree1(L5[4])):#print(L2,"L2",L5):
				L5:=subs(seq(var[t]=Ls[t],t=1..j-1),L[vars-j]):
				for t to nops(L1) do
					L6:=subs(var[j]=op(L1[t]),L5):
					L7:=newsamplesp(L6[1],L6[2]):
					for s to nops(L7) do
						L3:=[op(L3),[op(Ls),op(L1[t]),op(L7[s])]]:
					od:
				od:
				for t to nops(L2) do
					L6:=subs(var[j+1]=op(L2[t]),L5):
					L7:=newsamplesp(sqrfree1(L6[1]),sqrfree1(L6[2])):
					for s to nops(L7) do
						L3:=[op(L3),[op(Ls),op(L7[s]),op(L2[t])]]:
					od:
				od:
			od:
			sa:=L3:
			j:=j+1:
		fi:
	od:
	sas:=[]:

	for i from 1 to nops(sa) do:
		Ls:=sa[i]:
		sas:=[op(sas),[seq(var[t]=Ls[t],t=1..vars)]]:
	od:

	return sa:
end:
#################################################
#compute all samples for ineqpp
##########################################
p2Sample2:=proc(List,v)

	local var,vars,l,A,i,j,k,s,t,L,f,L1,L2,L3,L4,L5,P,Ls,sas,sa,g,h,L6,L7,L8,L9:
	L:=List:

	f:=List[1][1]:
	var:=[op(indets(f))]: vars:=nops(var): 
	sa:=samplesp(List[vars][1],List[vars][2]):
        #print(sa):
	for j from 2 to vars do
              # print(j):
		L3:=[]:
		L4:=[]:
		if nops(L[vars-j+1])=2 then 
			for k to nops(sa) do  
                               # print(k,'k',sa): print(L1):
				Ls:=sa[k]:    
				L5:=subs(seq(var[t]=Ls[t],t=1..j-1),L[vars-j+1]): #print(L5):
				L1:=samplesp(L5[1],L5[2]):
				for t to nops(L1) do
					L3:=[op(L3),[op(Ls),op(L1[t])]]:
				od:
			od:
			sa:=L3:
		else 
			for k to nops(sa) do 
                               # print(k,'k'): print(L1):
				Ls:=sa[k]:    
				L5:=subs(seq(var[t]=Ls[t],t=1..j-1),L[vars-j+1]): 
				L1:=samplesp(sqrfree1(L5[1]),sqrfree1(L5[3])):#print(L1,"L1",L5):
				L2:=samplesp(sqrfree1(L5[2]),sqrfree1(L5[4])):#print(L2,"L2",L5):
				L5:=subs(seq(var[t]=Ls[t],t=1..j-1),L[vars-j]):
				for t to nops(L1) do
					L6:=subs(var[j]=op(L1[t]),L5):
					L7:=samplesp(L6[1],L6[2]):
					for s to nops(L7) do
						L3:=[op(L3),[op(Ls),op(L1[t]),op(L7[s])]]:
					od:
				od:
				for t to nops(L2) do
					L6:=subs(var[j+1]=op(L2[t]),L5):
					L7:=samplesp(sqrfree1(L6[1]),sqrfree1(L6[2])):
					for s to nops(L7) do
						L3:=[op(L3),[op(Ls),op(L7[s]),op(L2[t])]]:
					od:
				od:
			od:
			sa:=L3:
			j:=j+1:
		fi:
	od:
	sas:=[]:

	for i from 1 to nops(sa) do:
		Ls:=sa[i]:
		sas:=[op(sas),[seq(var[t]=Ls[t],t=1..vars)]]:
	od:

	return sa:
end:
###################
proineq2:=proc(List,v)
	local var,vars,l,A,i,j,k,s,t,L,f,L1,L2,L3,L4,L5,P,Ls,sa,g,h,L6,L7,L8,L9:
	L:=List:
	if type(infolevel[proineq], numeric) and infolevel[proineq]>=2 then
		print(L):
	fi:
	f:=List[1][1]:
	var:=[op(indets(f))]: vars:=nops(var): 
	sa:=samples(List[vars][1],List[vars][2]):
	#print(sa,"sa"):
	for j from 2 to vars-1 do
		#print(j,"proineq2"):
		L3:=[]:
		L4:=[]:
		if nops(L[vars-j+1])=2 then 
			for k to nops(sa) do  
				#if j=8 then print(k,sa[k],j): 
				Ls:=sa[k]:    
				L5:=subs(seq(var[t]=Ls[t],t=1..j-1),L[vars-j+1]):
                                #if j=4 then print(L5):fi:
                                #print(L5):
				L1:=samples(L5[1],L5[2]):#print(L1):
				for t to nops(L1) do
					L3:=[op(L3),[op(Ls),op(L1[t])]]:
				od:
			od:
			sa:=L3:
		else 
			for k to nops(sa) do  #print(k): print(L1):
				#print(k,sa,j):
				Ls:=sa[k]:    
				#print(L[vars-j+1],"L[vars-j+1]",Ls,j):
				L5:=subs(seq(var[t]=Ls[t],t=1..j-1),L[vars-j+1]): 
				L1:=samples(sqrfree1(L5[1]),sqrfree1(L5[3])):#print(L1,"L1",L5):
				L2:=samples(sqrfree1(L5[2]),sqrfree1(L5[4])):#print(L2,"L2",L5):
				L5:=subs(seq(var[t]=Ls[t],t=1..j-1),L[vars-j]):
				for t to nops(L1) do
					#print(t,"L1",var[j],L1):
					L6:=subs(var[j]=op(L1[t]),L5):
					L7:=samples(L6[1],L6[2]):
					for s to nops(L7) do
						L3:=[op(L3),[op(Ls),op(L1[t]),op(L7[s])]]:
					od:
				od:
				for t to nops(L2) do
					#print(t,"t"):
					L6:=subs(var[j+1]=op(L2[t]),L5):
					L7:=samples(sqrfree1(L6[1]),sqrfree1(L6[2])):
					for s to nops(L7) do
						L3:=[op(L3),[op(Ls),op(L7[s]),op(L2[t])]]:
					od:
				od:
			od:
			sa:=L3:
			j:=j+1:
		fi:
	od:
	#print(sa):
	for i to nops(sa) do:
		Ls:=sa[i]:
		#print(subs(seq(var[t]=Ls[t],t=1..vars-1),f)):
		g:=sqrfree2(subs(seq(var[t]=Ls[t],t=1..vars-1),f)):#print(g,"g",var[1]):
		if realroot(g)<>[] then 
			return false:
		fi:
	od:
	#print(L):
	return nops(sa): 
end:


#############################################ȫ������
findk:=proc(poly,va,k)
	local L,f,g,i,j,t,s,L1,L2,var,vars,sa,L3,ti:
	ti:=time():
	f:=poly:#print(f):
	var:=va:
	vars:=nops(var):
	L1:=[]:
	L2:=[]:
	L:=[[1,f]]:
	for i to vars do
		L2:=[]:
		for t to nops(L) do
			L1:=fproj(L[t],var):
			L2:=[L1,op(L2)]:
		od:
		L:=L2:
		var:=[seq(var[j],j=1..vars-i)]:
		#print(L):
	od:
	g:=1:
	for i to nops(L) do
		g:=g*mul(L[i][j],j=1..nops(L[i])):
	od:
	g:=sqrfree1(g):
	L1:=sqrfree8(g):
	print(g,"g"):
	sa:=samples(g,1):
	print(sa):
	L:=[]:
	for i to nops(sa) do
		print(i,sa[i]):
		if proineq(subs(k=op(sa[i]),f))=true then L3:=[sa[i]]: 
			if i<>nops(sa) and i<>1 then
				s:=0:
				for j to nops(L1) while s=0 do
					if is(subs(k=op(sa[i]),L1[j])*subs(k=op(sa[i-1]),L1[j])<0)=true then s:=1: L3:=[op(L3),L1[j]]:
					fi:
				od:
				s:=0:
				for j to nops(L1) while s=0 do
					#print(j,"j",op(sa[i]),op(sa[i+1])):
					#if j=2 then print(subs(k=op(sa[i]),L1[j])*subs(k=op(sa[i+1]),L1[j]),is(subs(k=op(sa[i]),L1[j])*subs(k=op(sa[i+1]),L1[j])<0)):fi:
					if is(subs(k=op(sa[i]),L1[j])*subs(k=op(sa[i+1]),L1[j])<0)=true then s:=1: L3:=[op(L3),L1[j]]:
					fi:
				od:
			elif i=1 then L3:=[op(L3),-infinity]:
				s:=0: 
				for j to nops(L1) while s=0 do
					if is(subs(k=op(sa[i]),L1[j])*subs(k=op(sa[i+1]),L1[j])<0)=true then s:=1: L3:=[op(L3),L1[j]]:
					fi:
				od:
			else s:=0: 
				for j to nops(L1) while s=0 do
					if is(subs(k=op(sa[i]),L1[j])*subs(k=op(sa[i-1]),L1[j])<0)=true then s:=1: L3:=[op(L3),L1[j]]:
					fi:
				od:
				L3:=[op(L3),+infinity]:
			fi:
			L:=[op(L),L3]:
		fi:
	od:
	print(time()-ti):
	return(L,g):
end:

###################
#############################################ȫ������
findkmax:=proc(poly,va,k)
	local L,f,g,i,j,t,s,L1,L2,var,vars,sa,L3,ti:
	ti:=time():
	f:=poly:#print(f):
	var:=va:
	vars:=nops(var):
	L1:=[]:
	L2:=[]:
	L:=[[1,f]]:
	for i to vars do
		L2:=[]:
		for t to nops(L) do
			L1:=fproj(L[t],var):
			L2:=[L1,op(L2)]:
		od:

		L:=L2:
		#print(L,"L"):
		var:=[seq(var[j],j=1..vars-i)]:
		#print(L):
	od:
	g:=1:
	for i to nops(L) do
		g:=g*mul(L[i][j],j=1..nops(L[i])):
	od:
	#print(g,"g"):
	g:=sqrfree1(g):
	L1:=sqrfree8(g):
	#print(g,"g"):
	sa:=samples(g,1):
	L:=[]:
	t:=0:
	for i to nops(sa) while t=0 do
		print(i,sa[i]):
		if proineq(subs(k=op(sa[i]),f))=false then 
			t:=1:
			if i=1 or i=nops(L1) then 
				return false: 
			else L:=[[op(sa[i-1]),op(sa[i])]]: 
				s:=0:
				for j to nops(L1) while s=0 do
					if is(subs(k=op(sa[i]),L1[j])*subs(k=op(sa[i-1]),L1[j])<0)=true then s:=1: L:=[op(L),L1[j]]:
					fi:
				od:
			fi:
		fi:
	od:
	print(g):
	print(`The global supremum of`, k, `is the real root of`, L[2], `=0`, `which is between`, L[1]):
	print(time()-ti):
	return(L):
end:
#####################################
fproj1:=proc(poly,va)
	local L1,L2,i,j,var,vars,f,L,g:
	g:=1:
	var:=va:
	vars:=nops(var):
	if vars=0 then return poly: 
	fi:
	#print(List2):
	f:=res(poly,va[vars]):
	L:=sqrfree7(f):
	L1:=L[1]:
	L2:=L[2]:
	for i to nops(L2) do
		g:=sqrfree1(fproj1(L2[i],[seq(va[j],j=1..vars-1)])*g):
	od:
	for i to nops(L1) do
		g:=sqrfree1(fproj1(L1[i],[seq(va[j],j=1..vars-1)])*g):
	od:
	#print([L1,op(L2)],a):
	return(g):
end:
######################################
fproj2:=proc(poly,va)
	local L1,L2,i,j,var,vars,f,L,g:
	vars:=nops(va):
	if vars=0 then return poly: 
	fi:
	f:=sqrfree1(res(poly,va[vars])):
	g:=sqrfree1(res(f,[seq(va[j],j=1..vars-1)])):
	return(g):
end:
######################################
fproj:=proc(List,va)
	local L1,L2,i,j,var,vars,f,L,g:
	vars:=nops(va):
	L1:=1:
	L2:=[]:
	#print(List2):
	for i from 2 to nops(List) do
		f:=res(List[i],va[vars]):
		L:=sqrfree7(f):
		L1:=L[1][1]*L1:
		L2:=[op(L[2]),op(L2)]:
	od:
	g:=res(List[1],va[vars]):
	L1:=sqrfree1(g*L1):
	#print([L1,op(L2)],a):
	return([L1,op(L2)]):
end:
###################
res:=proc(poly,x)
	local var,vars,g,f:
	var:=indets(poly):   #print(poly,x):
	if member(x,var)=true
		then f:=(poly):
		g:=primpart(sqrfree1(resultant(f,diff(f,x),x))):
	else g:=poly 
	fi:
	return g
end:
###################
###################
Dres:=proc(poly,x)
	local var,vars,g,f:
	var:=indets(poly):   #print(poly,x):
	if member(x,var)=true
		then f:=(poly):
		g:=sqrfree1(primpart(gps([f,diff(f,x)],[x]))):
	else g:=poly
	fi:
	return g
end:
#####################
dis:=proc(poly,x)
	local var,vars,g,f,d:
	var:=indets(poly):
	if member(x,var)=true
		then d:=degree(poly,x): #print(d,x,poly):
		if d mod 2<>0 then return false:
		else g:=(-1)^(d/2)*discrim(poly,x):
		fi:
	else g:=poly 
	fi:
	return g
end:
##############################
disSample:=proc(poly,x)
	local var,vars,g,f,d:
	var:=indets(poly):
	if member(x,var)=true
		then d:=degree(poly,x): #print(d,x,poly):
		g:=(-1)^(d/2)*discrim(poly,x):
	else g:=poly 
	fi:
	return g
end:

######################
#################################################################
#   GPS is the gather procedure of Gather-and-Sift Algorithm.   #
#        Parameter: tsplst - Equations                          #
#                   tsvlst - Variables                          #
#        Notes: Number of tsplst should be number tsvlst plus 1 #
#        Modified by: Carl Liu - CICA                           #
#        Date: October 18, 2002                                 #
#################################################################

with(linalg):


#################################################################
#    i,j,k,lcvr        һ�����                                 #
#    st                ��ʼʱ��                                 #
#    npols             tsplst���̸���                           #
#    nvars             tsvlstδ֪�����                         #
#    tspowers          ָ���� (nvars)                           #
#    tsVr              ָ���� (nvars) (����)                  #
#    tsVrlst           tsVr��list                               #
#    tsA               nops�׷���                               #
#    tsB               nrs X nxy����                            #
#    tsC               tsB��˹��ȥ���õ��ľ���                  #
#    mu                GPS����ĵ���������                      #
#################################################################

gps := proc(tsplst,tsvlst)

	local i,j,k,lcvr,st,npols,nvars,tspowers,tsVr,tsVrlst,tsA,tsB,tsC,divby,
	subvar,subby,tsa,tsdp,tscl,tsvar,nxy,sxy,txy,nrs,trm,mu,um,t:

	st := time():
	npols := nops(tsplst):
	nvars := nops(tsvlst):
	tspowers := array(1..nvars):

	if not(npols = nvars + 1) then
		print(`Number of equations must be number of variables plus one!`):
		return:
	fi:

	tsA := array(1..npols,1..npols):
	tsVr := array(1..nvars):
	for i from 1 to nvars do
		lcvr := op(i,tsvlst):
		tsVr[i] := ts||lcvr||r
	od:
	tsVrlst := convert(tsVr, list):

	#################################################################
	# Setting up the first row of the matrix.
	#################################################################

	for i from 1 to npols do
		tsA[1,i] := op(i,tsplst):
	od:

	#################################################################
	# Setting up the remaining rows of the matrix.
	#################################################################

	divby := 1:
	for i from 2 to npols do
		subvar := op(i-1,tsvlst):
		subby := tsVr[i-1]:
		for j from 1 to npols do
			tsA[i,j] := subs(subvar=subby, tsA[i-1,j]):
		od:
	od:
	for i from npols by -1 to 2 do
		subvar := op(i-1,tsvlst):
		subby := tsVr[i-1]:
		for j from 1 to npols do
			tsA[i, j] := normal((tsA[i, j] - tsA[i-1, j])/(subvar - subby)):
		od:
	od:

	print(`Set up the First Matrix`):

	#################################################################
	#Compute the determinant of the matrix ... "dp".
	#################################################################

	tsa := normal(det(tsA)):
	tsdp := collect(tsa,tsVrlst,distributed):
	print(`Evaluated the First Determinant`):

	#################################################################
	# Setting up the actual Dixon Matrix.
	# tscl:=map(primpart,[coeffs(tsdp,tsVrlst,'trs')],tsvlst):
	#################################################################

	tscl:=[coeffs(tsdp,tsVrlst,'trs')]:
	coeffs(collect(tsdp,tsvlst,distributed),tsvlst,'txy'):
	tsvar := tsvlst:

	#################################################################
	#txy := sort([txy], tsF):
	#################################################################

	nxy := nops([txy]):
	sxy := sum(txy[q],q=1..nxy):
	txy := [op(sort(sxy,tsvlst,tdeg))]:

	nrs := nops(tscl):
	tsB := array(1..nrs,1..nxy):
	for i from 1 to nxy do
		trm := op(i,txy):
		for j from 1 to nvars do
			tspowers[j] := 0:
			while divide(trm,tsvlst[j]^(1 + tspowers[j])) do
				tspowers[j] := tspowers[j]+1:
			od:
		od:
		for j from 1 to nrs do
			tsB[j,i] := collect(tscl[j],tsvlst[1]):
			for k from 1 to nvars do
				tsB[j,i] := collect(tsB[j,i],tsvlst[k]):
				tsB[j,i] := coeff(tsB[j,i],tsvlst[k],tspowers[k]):
			od:
		od:
	od:

	print(`Set up the Dixon Matrix`):
	print(`Doing Gaussian Elimination`):
	tsC:=ffgausselim(tsB):
	um:=(multiply(tsC,txy)):
	print(`GPS is running about `,time()-st):
	#print(`tsC equals `,tsC):
	#print(`txy equals `,txy):
	mu:=factor(convert(um,list)):
	t:=nops(mu):
	#print(t,mu):
	RETURN(mu[t]):
end:

#################### �Ѷ���ʽƽ���������ƽ���������
sqrfree3:=proc(f)
	local n,L,i,k1,g,k2,k3,L1,L2:
	L:=factors(f):
	L1:=[]:
	L2:=1:
	n:=nops(L[2]):
	k3:=signum(L[1]):
	for i to n do 
		if  L[2][i][2] mod 2=0 then  
			L2:=L2*L[2][i][1]:
		else 
			if is (lcoeff(L[2][i][1])<0)=true then k3:=k3*(-1): 
				L1:=[op(L1),-L[2][i][1]]:
			else L1:=[op(L1),L[2][i][1]]:
			fi:
		fi:
	od:
	if k3=-1 then return false:
	fi:
	RETURN([L2,op(L1)]):
end:

#############################################
# �Ѷ���ʽƽ���������ƽ���������
#############################################
sqrfree3Sample:=proc(f)

	local n,L,i,g,L1,L2:
	L:=factors(f):
	L1:=[]:
	L2:=1:
	n:=nops(L[2]):
	for i to n do 
		if  L[2][i][2] mod 2=0 then  
			L2:=L2*L[2][i][1]:
		else 
			if is (lcoeff(L[2][i][1])<0)=true then 
				L1:=[op(L1),-L[2][i][1]]:
			else L1:=[op(L1),L[2][i][1]]: 
			fi:
		fi:
	od:
	RETURN([L2,op(L1)]):
end:


#################### �Ѷ���ʽƽ���������ƽ���������
sqrfree7:=proc(f)
	local n,L,i,k1,g,k2,k3,L1,L2:
	L:=factors(f):
	L1:=[]:
	L2:=1:
	n:=nops(L[2]):
	for i to n do 
		if  L[2][i][2] mod 2=0 then  
			L2:=L2*L[2][i][1]:
		else 
			L1:=[op(L1),L[2][i][1]]: 
		fi:
	od:
	RETURN([[L2],L1]):
end:

#################### ����ʽȥƽ������

sqrfree1:=proc(f)
	local L,nL:
	L:=factors(f):
	nL:=nops(L[2]):
	mul(L[2][i][1],i=1..nL):
end:
